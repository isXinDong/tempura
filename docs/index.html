<!DOCTYPE html>
<html>
<head>
<link rel="stylesheet" type="text/css" href="doc.css" />
<title>Neo</title>
</head>

<body>
<h1>Neo</h1>
<address>The Facebook Database Engineering Team</address>
<address>Build on earlier work on leveldb by Sanjay Ghemawat
               (sanjay@google.com) and Jeff Dean (jeff@google.com)</address>

<p>
<code>Neo</code> javascript machine learning library developed on AgentSmith. 
<p>
<h1>Neo.CrossDecomposition.CCA</h1>
<p>
<p>
<h2>fit(X,Y)</h2>
<p>
<table class="datatable">
  <tr>
    <td>
      <dt>parameters:</dt>
    </td>
    <td>
      <p><b>X</b> : training samples of domain 1 whose shape is [n_samples, n_features]. 
      <p><b>Y</b> : training samples of domain 2 whose shape is [n_samples, n_features]. 
      <small><p>*the number of samples of X and Y should be the same.</small>
    </td>
  </tr>
  <tr>
    <td>
      <dt>returns:</dt>
    </td>
    <td>
      <p><b>this</b> : instance of CCA, which has fitted parameters.
    </td>
  </tr>
</table>
<h2>transform(X,Y)</h2>
<p>
<table class="datatable">
  <tr>
    <td>
      <dt>parameters:</dt>
    </td>
    <td>
      <p><b>X</b> : test samples of domain 1 whose shape is [n_samples, n_features]. 
      <p><b>Y</b> : test samples of domain 2 whose shape is [n_samples, n_features]. 
      <small><p>*the number of samples of X and Y should be the same.</small>
    </td>
  </tr>
  <tr>
    <td>
      <dt>returns:</dt>
    </td>
    <td>
      <p><b>X_score</b> : samples of domain1 after projection onto latent space.
      <p><b>Y_score</b> : samples of domain1 after projection onto latent space.
    </td>
  </tr>
</table>
<p>

<h1>Neo.Mixture.GMM(n_components, n_iter, thresh, min_covar)</h1>
<table class="datatable">
  <tr>
    <td>
      <dt>parameters:</dt>
    </td>
    <td>
      <p><b>n_components</b> : int, default 1, the number of component of gmm
      <p><b>n_iter</b> : int, default 100, max iteration of Expectation and Maximization step of EM algorithm. 
      <p><b>thresh</b> : float, default 0.01, convergence criterion. 
      <p><b>min_covar</b> : float, default 0.01, floor on the diagonal of the covariance matrix to prevent overfitting
    </td>
  </tr>
</table>
<p>
<h2>fit(X)</h2>
<p>
<table class="datatable">
  <tr>
    <td>
      <dt>parameters:</dt>
    </td>
    <td>
      <p><b>X</b> : array [n_samples, n_feature], data matrix used for trainig gmm. Each row corresponds to a single data point.
    </td>
  </tr>
  <tr>
    <td>
      <dt>returns:</dt>
    </td>
    <td>
      <p><b>this</b> : instance of GMM, which has fitted parameters.
    </td>
  </tr>
</table>
<h2>calcLogLikelihood(X)</h2>
<p>
<table class="datatable">
  <tr>
    <td>
      <dt>parameters:</dt>
    </td>
    <td>
      <p><b>X</b> : array [n_samples, n_feature], data matrix.
    </td>
  </tr>
  <tr>
    <td>
      <dt>returns:</dt>
    </td>
    <td>
      <p><b>loglikelihood</b> : float, sum of negative log likelihood of given data X.
    </td>
  </tr>
</table>
<h2>showParams()</h2>
<p>
<table class="datatable">
  <tr>
    <td>
      <dt>parameters:</dt>
    </td>
    <td>
      <p><b></b> : None
    </td>
  </tr>
  <tr>
    <td>
      <dt>returns:</dt>
    </td>
    <td>
      <p><b></b> : None
    </td>
  </tr>
</table>
<p>
<h1>Neo.Cluster.Kmeans(n_clusters, init, n_jobs, maxiter, tol)</h1>
<p>
<table class="datatable">
  <tr>
    <td>
      <dt>parameters:</dt>
    </td>
    <td>
      <p><b>n_clusters</b> : int, default 8, number of clusters
      <p><b>init</b> : string, default "kmeans++", algorithm of initialization of clusters. 
      <small>*<b>init</b> should be "kmeans++" or "random".</small>
      <p><b>n_jobs</b> : int, default 1. the number of process when calculating k-means.
	<small>*<b>n_jobs</b> > 1 is not implemented now.</small>
      <p><b>maxiter</b> : int, default 300, max iteration of Expectation and Maximization step of EM algorithm. 
      <p><b>tol</b> : float, default 0.001, convergence criterion. 
    </td>
  </tr>
</table>
<h2>fit(X)</h2>
<p>
<table class="datatable">
  <tr>
    <td>
      <dt>parameters:</dt>
    </td>
    <td>
      <p><b>X</b> : array [n_samples, n_feature], data matrix used for trainig gmm. Each row corresponds to a single data point.
    </td>
  </tr>
  <tr>
    <td>
      <dt>returns:</dt>
    </td>
    <td>
      <p><b>this</b> : instance of GMM, which has fitted parameters.
    </td>
  </tr>
</table>
<p>
<h1>Neo.Decomposition.PCA(n_components, whiten)</h1>
<p>
<table class="datatable">
  <tr>
    <td>
      <dt>parameters:</dt>
    </td>
    <td>
      <p><b>n_components</b> : int, default 1, the number of dimension after reduction
      <p><b>whiten</b> : boolean, default false, whether whitening is applied or not
    </td>
  </tr>
</table>
<h2>fit(X)</h2>
<p>
<table class="datatable">
  <tr>
    <td>
      <dt>parameters:</dt>
    </td>
    <td>
      <p><b>X</b> : array [n_samples, n_feature], data matrix that dimension reduction is applied. Each row corresponds to a single data point.
    </td>
  </tr>
  <tr>
    <td>
      <dt>returns:</dt>
    </td>
    <td>
      <p><b>this</b> : instance of PCA, which has fitted parameters.
    </td>
  </tr>
</table>
<p>
<h1>Neo.Neighbors.NearestNeighbors</h1>
<p>
<p>
<h1>Neo.Neighbors.Classification</h1>
<p>
<p>
<h1>Neo.LinearModel.LinearRegression</h1>
<p>
<table class="datatable">
  <tr>
    <td>
      <dt>parameters:</dt>
    </td>
    <td>
      <p><b>center</b> : boolean, default true, whether data is centerized or not
      <p><b>normalize</b> : boolean, default true, whether data is normalized or not
      <p><b>solver</b> : string, default 'qr', solver used to calculate parameter
      <p><small>*<b>solver</b> should be "lrqr" or "qr".</small>
    </td>
  </tr>
</table>
<h2>fit(X, y)</h2>
<table class="datatable">
  <tr>
    <td>
      <dt>parameters:</dt>
    </td>
    <td>
      <p><b>X</b> : array [n_samples, n_feature], data matrix for training. each row corresponds to a single data point. 
      <p><b>y</b> : array [n_samples, 1], target vector. i-th element corresponds to the target value of i-th data of X.  
    </td>
  </tr>
  <tr>
    <td>
      <dt>returns:</dt>
    </td>
    <td>
      <p><b>this</b> : instance of Ridge Regression, which has fitted parameters.
    </td>
  </tr>
</table>
<p>
<h2>predict(X)</h2>
<table class="datatable">
  <tr>
    <td>
      <dt>parameters:</dt>
    </td>
    <td>
      <p><b>X</b> : array [n_samples, n_feature], data matrix used for prediction.
    </td>
  </tr>
  <tr>
    <td>
      <dt>returns:</dt>
    </td>
    <td>
      <p><b>pred</b> : array [n_samples, 1], i-th element corresponds to the target value of i-th data of test data.  
    </td>
  </tr>
</table>
<p>
<h1>Neo.LinearModel.Lasso</h1>
<p>
<table class="datatable">
  <tr>
    <td>
      <dt>parameters:</dt>
    </td>
    <td>
      <p><b>lambda</b> : float, default 1.0, constant value for avoiding overfit
      <p><b>center</b> : boolean, default true, whether data is centerized or not
      <p><b>normalize</b> : boolean, default true, whether data is normalized or not
      <p><b>n_iter</b> : int, default 1000, the number of iteration
      <p><b>tolerance</b> : int, default 0.0001, convergence criterion of cooridate decent.
    </td>
  </tr>
</table>
<h2>fit(X, y)</h2>
<table class="datatable">
  <tr>
    <td>
      <dt>parameters:</dt>
    </td>
    <td>
      <p><b>X</b> : array [n_samples, n_feature], data matrix for training. each row corresponds to a single data point. 
      <p><b>y</b> : array [n_samples, 1], target vector. i-th element corresponds to the target value of i-th data of X.  
    </td>
  </tr>
  <tr>
    <td>
      <dt>returns:</dt>
    </td>
    <td>
      <p><b>this</b> : instance of Ridge Regression, which has fitted parameters.
    </td>
  </tr>
</table>
<p>
<h2>predict(X)</h2>
<table class="datatable">
  <tr>
    <td>
      <dt>parameters:</dt>
    </td>
    <td>
      <p><b>X</b> : array [n_samples, n_feature], data matrix used for prediction.
    </td>
  </tr>
  <tr>
    <td>
      <dt>returns:</dt>
    </td>
    <td>
      <p><b>pred</b> : array [n_samples, 1], i-th element corresponds to the target value of i-th data of test data.  
    </td>
  </tr>
</table>
<p>
<h1>Neo.LinearModel.Ridge</h1>
<p>
<table class="datatable">
  <tr>
    <td>
      <dt>parameters:</dt>
    </td>
    <td>
      <p><b>lambda</b> : float, default 1.0, constant value for avoiding overfit
      <p><b>center</b> : boolean, default true, whether data is centerized or not
      <p><b>normalize</b> : boolean, default true, whether data is normalized or not
      <p><b>solver</b> : string, default 'cd', solver used to calculate parameter
      <p><small>*<b>solver</b> should be "lrqr" or "cd"(coordinate decent).</small>
      <p><b>n_iter</b> : int, default 1000, the number of iteration
      <p><b>tolerance</b> : int, default 0.0001, convergence criterion of cooridate decent.
    </td>
  </tr>
</table>
<p>
<h2>fit(X, y)</h2>
<table class="datatable">
  <tr>
    <td>
      <dt>parameters:</dt>
    </td>
    <td>
      <p><b>X</b> : array [n_samples, n_feature], data matrix for training. each row corresponds to a single data point. 
      <p><b>y</b> : array [n_samples, 1], target vector. i-th element corresponds to the target value of i-th data of X.  
    </td>
  </tr>
  <tr>
    <td>
      <dt>returns:</dt>
    </td>
    <td>
      <p><b>this</b> : instance of Ridge Regression, which has fitted parameters.
    </td>
  </tr>
</table>
<p>
<h2>predict(X)</h2>
<table class="datatable">
  <tr>
    <td>
      <dt>parameters:</dt>
    </td>
    <td>
      <p><b>X</b> : array [n_samples, n_feature], data matrix used for prediction.
    </td>
  </tr>
  <tr>
    <td>
      <dt>returns:</dt>
    </td>
    <td>
      <p><b>pred</b> : array [n_samples, 1], i-th element corresponds to the target value of i-th data of test data.  
    </td>
  </tr>
</table>

<h1>Neo.LinearModel.Logistic</h1>
<p>
<table class="datatable">
  <tr>
    <td>
      <dt>parameters:</dt>
    </td>
    <td>
      <p><b>eta</b> : float, default 0.01, learning ratio for delta Error
      <p><b>alpha</b> : float, default 0.015, l2-regularization strength
      <p><b>center</b> : boolean, default true, whether data is centerized or not
	<small>*<b>center</b> is not implemented.</small>
      <p><b>n_iter</b> : int, default 100, the number of iteration
    </td>
  </tr>
</table>
<h2>fit(X, y)</h2>
<p>
<table class="datatable">
  <tr>
    <td>
      <dt>parameters:</dt>
    </td>
    <td>
      <p><b>X</b> : array [n_samples, n_feature], data matrix for training. each row corresponds to a single data point. 
      <p><b>y</b> : array [n_samples, 1], target vector. i-th element corresponds to the target value of i-th data of X.  
    </td>
  </tr>
  <tr>
    <td>
      <dt>returns:</dt>
    </td>
    <td>
      <p><b>this</b> : instance of Logistic Regression, which has fitted parameters.
    </td>
  </tr>
</table>
<p>
<h2>predict(X)</h2>
<table class="datatable">
  <tr>
    <td>
      <dt>parameters:</dt>
    </td>
    <td>
      <p><b>X</b> : array [n_samples, n_feature], data matrix used for prediction.
    </td>
  </tr>
  <tr>
    <td>
      <dt>returns:</dt>
    </td>
    <td>
      <p><b>pred</b> : array [n_samples, 1], i-th element corresponds to the target value of i-th data of test data.  
    </td>
  </tr>
</table>
<p>
<h1>Neo.LinearModel.Perceptron</h1>
<p>
<p>
<h1>Neo.LinearModel.SGDRegressor</h1>
<p>
<table class="datatable">
  <tr>
    <td>
      <dt>parameters:</dt>
    </td>
    <td>
      <p><b>algorithm</b> : string, default 'sgdsvm', algorithm for online training
      <p><small>*<b>init</b> should be "sgdsvm" or "perceptron".</small>
      <p><b>n_iter</b> : int, default 1000, the number of iteration
      <p><b>t_zero</b> : float, default 1.0, value to decide step size alpha   
      <p><b>aver</b> : boolean, default true, whether averaging is used or not
    </td>
  </tr>
</table>

<h2>fit(X, y, init_w)</h2>
<p>
<table class="datatable">
  <tr>
    <td>
      <dt>parameters:</dt>
    </td>
    <td>
      <p><b>X</b> : array [n_samples, n_feature], data matrix of training samples. Each row corresponds to a single data point.
      <p><b>y</b> : array [n_samples, n_class], label matrix of training samples. Each row corresponds to label information of single data.
      <p><b>init_w</b> : array [n_feature+1, n_class], initial value of weight parameter
    </td>
  </tr>
  <tr>
    <td>
      <dt>returns:</dt>
    </td>
    <td>
      <p><b>this</b> : instance of Regressor, which has fitted parameters.
    </td>
  </tr>
</table>
<p>
  <h2>predict(X)</h2>
<table class="datatable">
  <tr>
    <td>
      <dt>parameters:</dt>
    </td>
    <td>
      <p><b>X</b> : array [n_samples, n_feature], data matrix used for prediction.
    </td>
  </tr>
  <tr>
    <td>
      <dt>returns:</dt>
    </td>
    <td>
      <p><b>pred</b> : array [n_samples, 1], i-th element corresponds to the target value of i-th data of test data.  
    </td>
  </tr>
</table>

<p>
<p>
<a href="https://github.com/facebook/rocksdb/wiki/Merge-Operator">
    Merge Operator</a>
<p>
<a href="https://github.com/facebook/rocksdb/wiki/Merge-Operator-Implementation">
    Merge Operator Implementation</a>

<p>
</body>
</html>
